guix build mes  --no-grafts   --no-substitutes   --check


This software, known as Cannoli, functions within QEMU to process and
analyze instructions during emulation. The core operation, referred to
as "lifting," involves disassembling target instructions and
transforming them into an Intermediate Language (IL) or executing them
on another architecture. Since QEMU stores lifted instructions in a
cache, these function calls occur infrequently compared to the
execution of the instructions themselves. This makes it ideal for
implementing smart logic filters, as hooking select few instructions
would minimize performance overhead.

Cannoli consists of two components: an API and a client. The API is
designed with multithreading in mind, allowing complex analysis of
data generated by QEMU without compromising the single-core
performance within QEMU itself. To use Cannoli, implement the
`Cannoli` trait on your structure, defining `init` to create both
mutable and immutable contexts for threading.

As a `Cannoli` implementer, you may choose to implement optional
callback functions, which include execution-related operations like
`exec`, `read`, and `write`. These callbacks can be triggered
concurrently from multiple threads, necessitating stateless
processing. Additionally, the callbacks have read-only access to the
multi-threaded shared immutable context, as they run in parallel.

The main callbacks (e.g., `exec`) provide a buffer for storing events
of type `Self::Trace`. By pushing values to this buffer, you can
sequence data and ensure that it is processed in the correct order
when the trace is processed in the `trace()` callback. The `trace()`
callback offers sequential access to mutable `self`, as well as a
reference to the shared context, allowing you to analyze the collected
data effectively.

In summary, Cannoli enables parallel processing of instruction streams
until sequential analysis is required, making it ideal for handling
vast amounts of data generated by QEMU without bottlenecking its
performance.

